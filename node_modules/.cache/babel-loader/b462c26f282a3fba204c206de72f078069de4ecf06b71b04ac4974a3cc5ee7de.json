{"ast":null,"code":"// Generated by CoffeeScript 1.10.0\nvar DATE_MAX_YEAR, DATE_MIN_YEAR, DATE_SPLITS, GRAPHS, L33T_TABLE, RANKED_DICTIONARIES, REGEXEN, adjacency_graphs, build_ranked_dict, frequency_lists, lst, matching, name, scoring;\nfrequency_lists = require('./frequency_lists');\nadjacency_graphs = require('./adjacency_graphs');\nscoring = require('./scoring');\nbuild_ranked_dict = function (ordered_list) {\n  var i, len1, o, result, word;\n  result = {};\n  i = 1;\n  for (o = 0, len1 = ordered_list.length; o < len1; o++) {\n    word = ordered_list[o];\n    result[word] = i;\n    i += 1;\n  }\n  return result;\n};\nRANKED_DICTIONARIES = {};\nfor (name in frequency_lists) {\n  lst = frequency_lists[name];\n  RANKED_DICTIONARIES[name] = build_ranked_dict(lst);\n}\nGRAPHS = {\n  qwerty: adjacency_graphs.qwerty,\n  dvorak: adjacency_graphs.dvorak,\n  keypad: adjacency_graphs.keypad,\n  mac_keypad: adjacency_graphs.mac_keypad\n};\nL33T_TABLE = {\n  a: ['4', '@'],\n  b: ['8'],\n  c: ['(', '{', '[', '<'],\n  e: ['3'],\n  g: ['6', '9'],\n  i: ['1', '!', '|'],\n  l: ['1', '|', '7'],\n  o: ['0'],\n  s: ['$', '5'],\n  t: ['+', '7'],\n  x: ['%'],\n  z: ['2']\n};\nREGEXEN = {\n  recent_year: /19\\d\\d|200\\d|201\\d/g\n};\nDATE_MAX_YEAR = 2050;\nDATE_MIN_YEAR = 1000;\nDATE_SPLITS = {\n  4: [[1, 2], [2, 3]],\n  5: [[1, 3], [2, 3]],\n  6: [[1, 2], [2, 4], [4, 5]],\n  7: [[1, 3], [2, 3], [4, 5], [4, 6]],\n  8: [[2, 4], [4, 6]]\n};\nmatching = {\n  empty: function (obj) {\n    var k;\n    return function () {\n      var results;\n      results = [];\n      for (k in obj) {\n        results.push(k);\n      }\n      return results;\n    }().length === 0;\n  },\n  extend: function (lst, lst2) {\n    return lst.push.apply(lst, lst2);\n  },\n  translate: function (string, chr_map) {\n    var chr;\n    return function () {\n      var len1, o, ref, results;\n      ref = string.split('');\n      results = [];\n      for (o = 0, len1 = ref.length; o < len1; o++) {\n        chr = ref[o];\n        results.push(chr_map[chr] || chr);\n      }\n      return results;\n    }().join('');\n  },\n  mod: function (n, m) {\n    return (n % m + m) % m;\n  },\n  sorted: function (matches) {\n    return matches.sort(function (m1, m2) {\n      return m1.i - m2.i || m1.j - m2.j;\n    });\n  },\n  omnimatch: function (password) {\n    var len1, matcher, matchers, matches, o;\n    matches = [];\n    matchers = [this.dictionary_match, this.reverse_dictionary_match, this.l33t_match, this.spatial_match, this.repeat_match, this.sequence_match, this.regex_match, this.date_match];\n    for (o = 0, len1 = matchers.length; o < len1; o++) {\n      matcher = matchers[o];\n      this.extend(matches, matcher.call(this, password));\n    }\n    return this.sorted(matches);\n  },\n  dictionary_match: function (password, _ranked_dictionaries) {\n    var dictionary_name, i, j, len, matches, o, p, password_lower, rank, ranked_dict, ref, ref1, ref2, word;\n    if (_ranked_dictionaries == null) {\n      _ranked_dictionaries = RANKED_DICTIONARIES;\n    }\n    matches = [];\n    len = password.length;\n    password_lower = password.toLowerCase();\n    for (dictionary_name in _ranked_dictionaries) {\n      ranked_dict = _ranked_dictionaries[dictionary_name];\n      for (i = o = 0, ref = len; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        for (j = p = ref1 = i, ref2 = len; ref1 <= ref2 ? p < ref2 : p > ref2; j = ref1 <= ref2 ? ++p : --p) {\n          if (password_lower.slice(i, +j + 1 || 9e9) in ranked_dict) {\n            word = password_lower.slice(i, +j + 1 || 9e9);\n            rank = ranked_dict[word];\n            matches.push({\n              pattern: 'dictionary',\n              i: i,\n              j: j,\n              token: password.slice(i, +j + 1 || 9e9),\n              matched_word: word,\n              rank: rank,\n              dictionary_name: dictionary_name,\n              reversed: false,\n              l33t: false\n            });\n          }\n        }\n      }\n    }\n    return this.sorted(matches);\n  },\n  reverse_dictionary_match: function (password, _ranked_dictionaries) {\n    var len1, match, matches, o, ref, reversed_password;\n    if (_ranked_dictionaries == null) {\n      _ranked_dictionaries = RANKED_DICTIONARIES;\n    }\n    reversed_password = password.split('').reverse().join('');\n    matches = this.dictionary_match(reversed_password, _ranked_dictionaries);\n    for (o = 0, len1 = matches.length; o < len1; o++) {\n      match = matches[o];\n      match.token = match.token.split('').reverse().join('');\n      match.reversed = true;\n      ref = [password.length - 1 - match.j, password.length - 1 - match.i], match.i = ref[0], match.j = ref[1];\n    }\n    return this.sorted(matches);\n  },\n  set_user_input_dictionary: function (ordered_list) {\n    return RANKED_DICTIONARIES['user_inputs'] = build_ranked_dict(ordered_list.slice());\n  },\n  relevant_l33t_subtable: function (password, table) {\n    var chr, len1, letter, o, password_chars, ref, relevant_subs, sub, subs, subtable;\n    password_chars = {};\n    ref = password.split('');\n    for (o = 0, len1 = ref.length; o < len1; o++) {\n      chr = ref[o];\n      password_chars[chr] = true;\n    }\n    subtable = {};\n    for (letter in table) {\n      subs = table[letter];\n      relevant_subs = function () {\n        var len2, p, results;\n        results = [];\n        for (p = 0, len2 = subs.length; p < len2; p++) {\n          sub = subs[p];\n          if (sub in password_chars) {\n            results.push(sub);\n          }\n        }\n        return results;\n      }();\n      if (relevant_subs.length > 0) {\n        subtable[letter] = relevant_subs;\n      }\n    }\n    return subtable;\n  },\n  enumerate_l33t_subs: function (table) {\n    var chr, dedup, helper, k, keys, l33t_chr, len1, len2, o, p, ref, sub, sub_dict, sub_dicts, subs;\n    keys = function () {\n      var results;\n      results = [];\n      for (k in table) {\n        results.push(k);\n      }\n      return results;\n    }();\n    subs = [[]];\n    dedup = function (subs) {\n      var assoc, deduped, label, len1, members, o, sub, v;\n      deduped = [];\n      members = {};\n      for (o = 0, len1 = subs.length; o < len1; o++) {\n        sub = subs[o];\n        assoc = function () {\n          var len2, p, results;\n          results = [];\n          for (v = p = 0, len2 = sub.length; p < len2; v = ++p) {\n            k = sub[v];\n            results.push([k, v]);\n          }\n          return results;\n        }();\n        assoc.sort();\n        label = function () {\n          var len2, p, results;\n          results = [];\n          for (v = p = 0, len2 = assoc.length; p < len2; v = ++p) {\n            k = assoc[v];\n            results.push(k + ',' + v);\n          }\n          return results;\n        }().join('-');\n        if (!(label in members)) {\n          members[label] = true;\n          deduped.push(sub);\n        }\n      }\n      return deduped;\n    };\n    helper = function (keys) {\n      var dup_l33t_index, first_key, i, l33t_chr, len1, len2, next_subs, o, p, q, ref, ref1, rest_keys, sub, sub_alternative, sub_extension;\n      if (!keys.length) {\n        return;\n      }\n      first_key = keys[0];\n      rest_keys = keys.slice(1);\n      next_subs = [];\n      ref = table[first_key];\n      for (o = 0, len1 = ref.length; o < len1; o++) {\n        l33t_chr = ref[o];\n        for (p = 0, len2 = subs.length; p < len2; p++) {\n          sub = subs[p];\n          dup_l33t_index = -1;\n          for (i = q = 0, ref1 = sub.length; 0 <= ref1 ? q < ref1 : q > ref1; i = 0 <= ref1 ? ++q : --q) {\n            if (sub[i][0] === l33t_chr) {\n              dup_l33t_index = i;\n              break;\n            }\n          }\n          if (dup_l33t_index === -1) {\n            sub_extension = sub.concat([[l33t_chr, first_key]]);\n            next_subs.push(sub_extension);\n          } else {\n            sub_alternative = sub.slice(0);\n            sub_alternative.splice(dup_l33t_index, 1);\n            sub_alternative.push([l33t_chr, first_key]);\n            next_subs.push(sub);\n            next_subs.push(sub_alternative);\n          }\n        }\n      }\n      subs = dedup(next_subs);\n      return helper(rest_keys);\n    };\n    helper(keys);\n    sub_dicts = [];\n    for (o = 0, len1 = subs.length; o < len1; o++) {\n      sub = subs[o];\n      sub_dict = {};\n      for (p = 0, len2 = sub.length; p < len2; p++) {\n        ref = sub[p], l33t_chr = ref[0], chr = ref[1];\n        sub_dict[l33t_chr] = chr;\n      }\n      sub_dicts.push(sub_dict);\n    }\n    return sub_dicts;\n  },\n  l33t_match: function (password, _ranked_dictionaries, _l33t_table) {\n    var chr, k, len1, len2, match, match_sub, matches, o, p, ref, ref1, sub, subbed_chr, subbed_password, token, v;\n    if (_ranked_dictionaries == null) {\n      _ranked_dictionaries = RANKED_DICTIONARIES;\n    }\n    if (_l33t_table == null) {\n      _l33t_table = L33T_TABLE;\n    }\n    matches = [];\n    ref = this.enumerate_l33t_subs(this.relevant_l33t_subtable(password, _l33t_table));\n    for (o = 0, len1 = ref.length; o < len1; o++) {\n      sub = ref[o];\n      if (this.empty(sub)) {\n        break;\n      }\n      subbed_password = this.translate(password, sub);\n      ref1 = this.dictionary_match(subbed_password, _ranked_dictionaries);\n      for (p = 0, len2 = ref1.length; p < len2; p++) {\n        match = ref1[p];\n        token = password.slice(match.i, +match.j + 1 || 9e9);\n        if (token.toLowerCase() === match.matched_word) {\n          continue;\n        }\n        match_sub = {};\n        for (subbed_chr in sub) {\n          chr = sub[subbed_chr];\n          if (token.indexOf(subbed_chr) !== -1) {\n            match_sub[subbed_chr] = chr;\n          }\n        }\n        match.l33t = true;\n        match.token = token;\n        match.sub = match_sub;\n        match.sub_display = function () {\n          var results;\n          results = [];\n          for (k in match_sub) {\n            v = match_sub[k];\n            results.push(k + \" -> \" + v);\n          }\n          return results;\n        }().join(', ');\n        matches.push(match);\n      }\n    }\n    return this.sorted(matches.filter(function (match) {\n      return match.token.length > 1;\n    }));\n  },\n  spatial_match: function (password, _graphs) {\n    var graph, graph_name, matches;\n    if (_graphs == null) {\n      _graphs = GRAPHS;\n    }\n    matches = [];\n    for (graph_name in _graphs) {\n      graph = _graphs[graph_name];\n      this.extend(matches, this.spatial_match_helper(password, graph, graph_name));\n    }\n    return this.sorted(matches);\n  },\n  SHIFTED_RX: /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/,\n  spatial_match_helper: function (password, graph, graph_name) {\n    var adj, adjacents, cur_char, cur_direction, found, found_direction, i, j, last_direction, len1, matches, o, prev_char, shifted_count, turns;\n    matches = [];\n    i = 0;\n    while (i < password.length - 1) {\n      j = i + 1;\n      last_direction = null;\n      turns = 0;\n      if ((graph_name === 'qwerty' || graph_name === 'dvorak') && this.SHIFTED_RX.exec(password.charAt(i))) {\n        shifted_count = 1;\n      } else {\n        shifted_count = 0;\n      }\n      while (true) {\n        prev_char = password.charAt(j - 1);\n        found = false;\n        found_direction = -1;\n        cur_direction = -1;\n        adjacents = graph[prev_char] || [];\n        if (j < password.length) {\n          cur_char = password.charAt(j);\n          for (o = 0, len1 = adjacents.length; o < len1; o++) {\n            adj = adjacents[o];\n            cur_direction += 1;\n            if (adj && adj.indexOf(cur_char) !== -1) {\n              found = true;\n              found_direction = cur_direction;\n              if (adj.indexOf(cur_char) === 1) {\n                shifted_count += 1;\n              }\n              if (last_direction !== found_direction) {\n                turns += 1;\n                last_direction = found_direction;\n              }\n              break;\n            }\n          }\n        }\n        if (found) {\n          j += 1;\n        } else {\n          if (j - i > 2) {\n            matches.push({\n              pattern: 'spatial',\n              i: i,\n              j: j - 1,\n              token: password.slice(i, j),\n              graph: graph_name,\n              turns: turns,\n              shifted_count: shifted_count\n            });\n          }\n          i = j;\n          break;\n        }\n      }\n    }\n    return matches;\n  },\n  repeat_match: function (password) {\n    var base_analysis, base_guesses, base_matches, base_token, greedy, greedy_match, i, j, lastIndex, lazy, lazy_anchored, lazy_match, match, matches, ref;\n    matches = [];\n    greedy = /(.+)\\1+/g;\n    lazy = /(.+?)\\1+/g;\n    lazy_anchored = /^(.+?)\\1+$/;\n    lastIndex = 0;\n    while (lastIndex < password.length) {\n      greedy.lastIndex = lazy.lastIndex = lastIndex;\n      greedy_match = greedy.exec(password);\n      lazy_match = lazy.exec(password);\n      if (greedy_match == null) {\n        break;\n      }\n      if (greedy_match[0].length > lazy_match[0].length) {\n        match = greedy_match;\n        base_token = lazy_anchored.exec(match[0])[1];\n      } else {\n        match = lazy_match;\n        base_token = match[1];\n      }\n      ref = [match.index, match.index + match[0].length - 1], i = ref[0], j = ref[1];\n      base_analysis = scoring.most_guessable_match_sequence(base_token, this.omnimatch(base_token));\n      base_matches = base_analysis.sequence;\n      base_guesses = base_analysis.guesses;\n      matches.push({\n        pattern: 'repeat',\n        i: i,\n        j: j,\n        token: match[0],\n        base_token: base_token,\n        base_guesses: base_guesses,\n        base_matches: base_matches,\n        repeat_count: match[0].length / base_token.length\n      });\n      lastIndex = j + 1;\n    }\n    return matches;\n  },\n  MAX_DELTA: 5,\n  sequence_match: function (password) {\n    var delta, i, j, k, last_delta, o, ref, result, update;\n    if (password.length === 1) {\n      return [];\n    }\n    update = function (_this) {\n      return function (i, j, delta) {\n        var ref, sequence_name, sequence_space, token;\n        if (j - i > 1 || Math.abs(delta) === 1) {\n          if (0 < (ref = Math.abs(delta)) && ref <= _this.MAX_DELTA) {\n            token = password.slice(i, +j + 1 || 9e9);\n            if (/^[a-z]+$/.test(token)) {\n              sequence_name = 'lower';\n              sequence_space = 26;\n            } else if (/^[A-Z]+$/.test(token)) {\n              sequence_name = 'upper';\n              sequence_space = 26;\n            } else if (/^\\d+$/.test(token)) {\n              sequence_name = 'digits';\n              sequence_space = 10;\n            } else {\n              sequence_name = 'unicode';\n              sequence_space = 26;\n            }\n            return result.push({\n              pattern: 'sequence',\n              i: i,\n              j: j,\n              token: password.slice(i, +j + 1 || 9e9),\n              sequence_name: sequence_name,\n              sequence_space: sequence_space,\n              ascending: delta > 0\n            });\n          }\n        }\n      };\n    }(this);\n    result = [];\n    i = 0;\n    last_delta = null;\n    for (k = o = 1, ref = password.length; 1 <= ref ? o < ref : o > ref; k = 1 <= ref ? ++o : --o) {\n      delta = password.charCodeAt(k) - password.charCodeAt(k - 1);\n      if (last_delta == null) {\n        last_delta = delta;\n      }\n      if (delta === last_delta) {\n        continue;\n      }\n      j = k - 1;\n      update(i, j, last_delta);\n      i = j;\n      last_delta = delta;\n    }\n    update(i, password.length - 1, last_delta);\n    return result;\n  },\n  regex_match: function (password, _regexen) {\n    var matches, regex, rx_match, token;\n    if (_regexen == null) {\n      _regexen = REGEXEN;\n    }\n    matches = [];\n    for (name in _regexen) {\n      regex = _regexen[name];\n      regex.lastIndex = 0;\n      while (rx_match = regex.exec(password)) {\n        token = rx_match[0];\n        matches.push({\n          pattern: 'regex',\n          token: token,\n          i: rx_match.index,\n          j: rx_match.index + rx_match[0].length - 1,\n          regex_name: name,\n          regex_match: rx_match\n        });\n      }\n    }\n    return this.sorted(matches);\n  },\n  date_match: function (password) {\n    var best_candidate, candidate, candidates, distance, dmy, i, j, k, l, len1, len2, matches, maybe_date_no_separator, maybe_date_with_separator, metric, min_distance, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, rx_match, s, t, token;\n    matches = [];\n    maybe_date_no_separator = /^\\d{4,8}$/;\n    maybe_date_with_separator = /^(\\d{1,4})([\\s\\/\\\\_.-])(\\d{1,2})\\2(\\d{1,4})$/;\n    for (i = o = 0, ref = password.length - 4; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {\n      for (j = p = ref1 = i + 3, ref2 = i + 7; ref1 <= ref2 ? p <= ref2 : p >= ref2; j = ref1 <= ref2 ? ++p : --p) {\n        if (j >= password.length) {\n          break;\n        }\n        token = password.slice(i, +j + 1 || 9e9);\n        if (!maybe_date_no_separator.exec(token)) {\n          continue;\n        }\n        candidates = [];\n        ref3 = DATE_SPLITS[token.length];\n        for (q = 0, len1 = ref3.length; q < len1; q++) {\n          ref4 = ref3[q], k = ref4[0], l = ref4[1];\n          dmy = this.map_ints_to_dmy([parseInt(token.slice(0, k)), parseInt(token.slice(k, l)), parseInt(token.slice(l))]);\n          if (dmy != null) {\n            candidates.push(dmy);\n          }\n        }\n        if (!(candidates.length > 0)) {\n          continue;\n        }\n        best_candidate = candidates[0];\n        metric = function (candidate) {\n          return Math.abs(candidate.year - scoring.REFERENCE_YEAR);\n        };\n        min_distance = metric(candidates[0]);\n        ref5 = candidates.slice(1);\n        for (r = 0, len2 = ref5.length; r < len2; r++) {\n          candidate = ref5[r];\n          distance = metric(candidate);\n          if (distance < min_distance) {\n            ref6 = [candidate, distance], best_candidate = ref6[0], min_distance = ref6[1];\n          }\n        }\n        matches.push({\n          pattern: 'date',\n          token: token,\n          i: i,\n          j: j,\n          separator: '',\n          year: best_candidate.year,\n          month: best_candidate.month,\n          day: best_candidate.day\n        });\n      }\n    }\n    for (i = s = 0, ref7 = password.length - 6; 0 <= ref7 ? s <= ref7 : s >= ref7; i = 0 <= ref7 ? ++s : --s) {\n      for (j = t = ref8 = i + 5, ref9 = i + 9; ref8 <= ref9 ? t <= ref9 : t >= ref9; j = ref8 <= ref9 ? ++t : --t) {\n        if (j >= password.length) {\n          break;\n        }\n        token = password.slice(i, +j + 1 || 9e9);\n        rx_match = maybe_date_with_separator.exec(token);\n        if (rx_match == null) {\n          continue;\n        }\n        dmy = this.map_ints_to_dmy([parseInt(rx_match[1]), parseInt(rx_match[3]), parseInt(rx_match[4])]);\n        if (dmy == null) {\n          continue;\n        }\n        matches.push({\n          pattern: 'date',\n          token: token,\n          i: i,\n          j: j,\n          separator: rx_match[2],\n          year: dmy.year,\n          month: dmy.month,\n          day: dmy.day\n        });\n      }\n    }\n    return this.sorted(matches.filter(function (match) {\n      var is_submatch, len3, other_match, u;\n      is_submatch = false;\n      for (u = 0, len3 = matches.length; u < len3; u++) {\n        other_match = matches[u];\n        if (match === other_match) {\n          continue;\n        }\n        if (other_match.i <= match.i && other_match.j >= match.j) {\n          is_submatch = true;\n          break;\n        }\n      }\n      return !is_submatch;\n    }));\n  },\n  map_ints_to_dmy: function (ints) {\n    var dm, int, len1, len2, len3, o, over_12, over_31, p, possible_year_splits, q, ref, ref1, rest, under_1, y;\n    if (ints[1] > 31 || ints[1] <= 0) {\n      return;\n    }\n    over_12 = 0;\n    over_31 = 0;\n    under_1 = 0;\n    for (o = 0, len1 = ints.length; o < len1; o++) {\n      int = ints[o];\n      if (99 < int && int < DATE_MIN_YEAR || int > DATE_MAX_YEAR) {\n        return;\n      }\n      if (int > 31) {\n        over_31 += 1;\n      }\n      if (int > 12) {\n        over_12 += 1;\n      }\n      if (int <= 0) {\n        under_1 += 1;\n      }\n    }\n    if (over_31 >= 2 || over_12 === 3 || under_1 >= 2) {\n      return;\n    }\n    possible_year_splits = [[ints[2], ints.slice(0, 2)], [ints[0], ints.slice(1, 3)]];\n    for (p = 0, len2 = possible_year_splits.length; p < len2; p++) {\n      ref = possible_year_splits[p], y = ref[0], rest = ref[1];\n      if (DATE_MIN_YEAR <= y && y <= DATE_MAX_YEAR) {\n        dm = this.map_ints_to_dm(rest);\n        if (dm != null) {\n          return {\n            year: y,\n            month: dm.month,\n            day: dm.day\n          };\n        } else {\n          return;\n        }\n      }\n    }\n    for (q = 0, len3 = possible_year_splits.length; q < len3; q++) {\n      ref1 = possible_year_splits[q], y = ref1[0], rest = ref1[1];\n      dm = this.map_ints_to_dm(rest);\n      if (dm != null) {\n        y = this.two_to_four_digit_year(y);\n        return {\n          year: y,\n          month: dm.month,\n          day: dm.day\n        };\n      }\n    }\n  },\n  map_ints_to_dm: function (ints) {\n    var d, len1, m, o, ref, ref1;\n    ref = [ints, ints.slice().reverse()];\n    for (o = 0, len1 = ref.length; o < len1; o++) {\n      ref1 = ref[o], d = ref1[0], m = ref1[1];\n      if (1 <= d && d <= 31 && 1 <= m && m <= 12) {\n        return {\n          day: d,\n          month: m\n        };\n      }\n    }\n  },\n  two_to_four_digit_year: function (year) {\n    if (year > 99) {\n      return year;\n    } else if (year > 50) {\n      return year + 1900;\n    } else {\n      return year + 2000;\n    }\n  }\n};\nmodule.exports = matching;","map":{"version":3,"names":["DATE_MAX_YEAR","DATE_MIN_YEAR","DATE_SPLITS","GRAPHS","L33T_TABLE","RANKED_DICTIONARIES","REGEXEN","adjacency_graphs","build_ranked_dict","frequency_lists","lst","matching","name","scoring","require","ordered_list","i","len1","o","result","word","length","qwerty","dvorak","keypad","mac_keypad","a","b","c","e","g","l","s","t","x","z","recent_year","empty","obj","k","results","extend","lst2","push","apply","translate","string","chr_map","chr","ref","split","join","mod","n","m","sorted","matches","sort","m1","m2","j","omnimatch","password","matcher","matchers","dictionary_match","reverse_dictionary_match","l33t_match","spatial_match","repeat_match","sequence_match","regex_match","date_match","call","_ranked_dictionaries","dictionary_name","len","p","password_lower","rank","ranked_dict","ref1","ref2","toLowerCase","slice","pattern","token","matched_word","reversed","l33t","match","reversed_password","reverse","set_user_input_dictionary","relevant_l33t_subtable","table","letter","password_chars","relevant_subs","sub","subs","subtable","len2","enumerate_l33t_subs","dedup","helper","keys","l33t_chr","sub_dict","sub_dicts","assoc","deduped","label","members","v","dup_l33t_index","first_key","next_subs","q","rest_keys","sub_alternative","sub_extension","concat","splice","_l33t_table","match_sub","subbed_chr","subbed_password","indexOf","sub_display","filter","_graphs","graph","graph_name","spatial_match_helper","SHIFTED_RX","adj","adjacents","cur_char","cur_direction","found","found_direction","last_direction","prev_char","shifted_count","turns","exec","charAt","base_analysis","base_guesses","base_matches","base_token","greedy","greedy_match","lastIndex","lazy","lazy_anchored","lazy_match","index","most_guessable_match_sequence","sequence","guesses","repeat_count","MAX_DELTA","delta","last_delta","update","_this","sequence_name","sequence_space","Math","abs","test","ascending","charCodeAt","_regexen","regex","rx_match","regex_name","best_candidate","candidate","candidates","distance","dmy","maybe_date_no_separator","maybe_date_with_separator","metric","min_distance","r","ref3","ref4","ref5","ref6","ref7","ref8","ref9","map_ints_to_dmy","parseInt","year","REFERENCE_YEAR","separator","month","day","is_submatch","len3","other_match","u","ints","dm","int","over_12","over_31","possible_year_splits","rest","under_1","y","map_ints_to_dm","two_to_four_digit_year","d","module","exports"],"sources":["C:\\uiux development\\frontend\\confessapp\\node_modules\\zxcvbn\\src\\matching.coffee"],"sourcesContent":["frequency_lists = require('./frequency_lists')\nadjacency_graphs = require('./adjacency_graphs')\nscoring = require('./scoring')\n\nbuild_ranked_dict = (ordered_list) ->\n  result = {}\n  i = 1 # rank starts at 1, not 0\n  for word in ordered_list\n    result[word] = i\n    i += 1\n  result\n\nRANKED_DICTIONARIES = {}\nfor name, lst of frequency_lists\n  RANKED_DICTIONARIES[name] = build_ranked_dict lst\n\nGRAPHS =\n  qwerty:     adjacency_graphs.qwerty\n  dvorak:     adjacency_graphs.dvorak\n  keypad:     adjacency_graphs.keypad\n  mac_keypad: adjacency_graphs.mac_keypad\n\nL33T_TABLE =\n  a: ['4', '@']\n  b: ['8']\n  c: ['(', '{', '[', '<']\n  e: ['3']\n  g: ['6', '9']\n  i: ['1', '!', '|']\n  l: ['1', '|', '7']\n  o: ['0']\n  s: ['$', '5']\n  t: ['+', '7']\n  x: ['%']\n  z: ['2']\n\nREGEXEN =\n  recent_year:  /19\\d\\d|200\\d|201\\d/g\n\nDATE_MAX_YEAR = 2050\nDATE_MIN_YEAR = 1000\nDATE_SPLITS =\n  4:[      # for length-4 strings, eg 1191 or 9111, two ways to split:\n    [1, 2] # 1 1 91 (2nd split starts at index 1, 3rd at index 2)\n    [2, 3] # 91 1 1\n    ]\n  5:[\n    [1, 3] # 1 11 91\n    [2, 3] # 11 1 91\n    ]\n  6:[\n    [1, 2] # 1 1 1991\n    [2, 4] # 11 11 91\n    [4, 5] # 1991 1 1\n    ]\n  7:[\n    [1, 3] # 1 11 1991\n    [2, 3] # 11 1 1991\n    [4, 5] # 1991 1 11\n    [4, 6] # 1991 11 1\n    ]\n  8:[\n    [2, 4] # 11 11 1991\n    [4, 6] # 1991 11 11\n    ]\n\nmatching =\n  empty: (obj) -> (k for k of obj).length == 0\n  extend: (lst, lst2) -> lst.push.apply lst, lst2\n  translate: (string, chr_map) -> (chr_map[chr] or chr for chr in string.split('')).join('')\n  mod: (n, m) -> ((n % m) + m) % m # mod impl that works for negative numbers\n  sorted: (matches) ->\n    # sort on i primary, j secondary\n    matches.sort (m1, m2) ->\n      (m1.i - m2.i) or (m1.j - m2.j)\n\n  # ------------------------------------------------------------------------------\n  # omnimatch -- combine everything ----------------------------------------------\n  # ------------------------------------------------------------------------------\n\n  omnimatch: (password) ->\n    matches = []\n    matchers = [\n      @dictionary_match\n      @reverse_dictionary_match\n      @l33t_match\n      @spatial_match\n      @repeat_match\n      @sequence_match\n      @regex_match\n      @date_match\n    ]\n    for matcher in matchers\n      @extend matches, matcher.call(this, password)\n    @sorted matches\n\n  #-------------------------------------------------------------------------------\n  # dictionary match (common passwords, english, last names, etc) ----------------\n  #-------------------------------------------------------------------------------\n\n  dictionary_match: (password, _ranked_dictionaries = RANKED_DICTIONARIES) ->\n    # _ranked_dictionaries variable is for unit testing purposes\n    matches = []\n    len = password.length\n    password_lower = password.toLowerCase()\n    for dictionary_name, ranked_dict of _ranked_dictionaries\n      for i in [0...len]\n        for j in [i...len]\n          if password_lower[i..j] of ranked_dict\n            word = password_lower[i..j]\n            rank = ranked_dict[word]\n            matches.push\n              pattern: 'dictionary'\n              i: i\n              j: j\n              token: password[i..j]\n              matched_word: word\n              rank: rank\n              dictionary_name: dictionary_name\n              reversed: false\n              l33t: false\n    @sorted matches\n\n  reverse_dictionary_match: (password, _ranked_dictionaries = RANKED_DICTIONARIES) ->\n    reversed_password = password.split('').reverse().join('')\n    matches = @dictionary_match reversed_password, _ranked_dictionaries\n    for match in matches\n      match.token = match.token.split('').reverse().join('') # reverse back\n      match.reversed = true\n      # map coordinates back to original string\n      [match.i, match.j] = [\n        password.length - 1 - match.j\n        password.length - 1 - match.i\n      ]\n    @sorted matches\n\n  set_user_input_dictionary: (ordered_list) ->\n    RANKED_DICTIONARIES['user_inputs'] = build_ranked_dict ordered_list.slice()\n\n  #-------------------------------------------------------------------------------\n  # dictionary match with common l33t substitutions ------------------------------\n  #-------------------------------------------------------------------------------\n\n  # makes a pruned copy of l33t_table that only includes password's possible substitutions\n  relevant_l33t_subtable: (password, table) ->\n    password_chars = {}\n    for chr in password.split('')\n      password_chars[chr] = true\n    subtable = {}\n    for letter, subs of table\n      relevant_subs = (sub for sub in subs when sub of password_chars)\n      if relevant_subs.length > 0\n        subtable[letter] = relevant_subs\n    subtable\n\n  # returns the list of possible 1337 replacement dictionaries for a given password\n  enumerate_l33t_subs: (table) ->\n    keys = (k for k of table)\n    subs = [[]]\n\n    dedup = (subs) ->\n      deduped = []\n      members = {}\n      for sub in subs\n        assoc = ([k,v] for k,v in sub)\n        assoc.sort()\n        label = (k+','+v for k,v in assoc).join('-')\n        unless label of members\n          members[label] = true\n          deduped.push sub\n      deduped\n\n    helper = (keys) ->\n      return if not keys.length\n      first_key = keys[0]\n      rest_keys = keys[1..]\n      next_subs = []\n      for l33t_chr in table[first_key]\n        for sub in subs\n          dup_l33t_index = -1\n          for i in [0...sub.length]\n            if sub[i][0] == l33t_chr\n              dup_l33t_index = i\n              break\n          if dup_l33t_index == -1\n            sub_extension = sub.concat [[l33t_chr, first_key]]\n            next_subs.push sub_extension\n          else\n            sub_alternative = sub.slice(0)\n            sub_alternative.splice(dup_l33t_index, 1)\n            sub_alternative.push [l33t_chr, first_key]\n            next_subs.push sub\n            next_subs.push sub_alternative\n      subs = dedup next_subs\n      helper(rest_keys)\n\n    helper(keys)\n    sub_dicts = [] # convert from assoc lists to dicts\n    for sub in subs\n      sub_dict = {}\n      for [l33t_chr, chr] in sub\n        sub_dict[l33t_chr] = chr\n      sub_dicts.push sub_dict\n    sub_dicts\n\n  l33t_match: (password, _ranked_dictionaries = RANKED_DICTIONARIES, _l33t_table = L33T_TABLE) ->\n    matches = []\n    for sub in @enumerate_l33t_subs @relevant_l33t_subtable(password, _l33t_table)\n      break if @empty sub # corner case: password has no relevant subs.\n      subbed_password = @translate password, sub\n      for match in @dictionary_match(subbed_password, _ranked_dictionaries)\n        token = password[match.i..match.j]\n        if token.toLowerCase() == match.matched_word\n          continue # only return the matches that contain an actual substitution\n        match_sub = {} # subset of mappings in sub that are in use for this match\n        for subbed_chr, chr of sub when token.indexOf(subbed_chr) != -1\n          match_sub[subbed_chr] = chr\n        match.l33t = true\n        match.token = token\n        match.sub = match_sub\n        match.sub_display = (\"#{k} -> #{v}\" for k,v of match_sub).join(', ')\n        matches.push match\n    @sorted matches.filter (match) ->\n      # filter single-character l33t matches to reduce noise.\n      # otherwise '1' matches 'i', '4' matches 'a', both very common English words\n      # with low dictionary rank.\n      match.token.length > 1\n\n  # ------------------------------------------------------------------------------\n  # spatial match (qwerty/dvorak/keypad) -----------------------------------------\n  # ------------------------------------------------------------------------------\n\n  spatial_match: (password, _graphs = GRAPHS) ->\n    matches = []\n    for graph_name, graph of _graphs\n      @extend matches, @spatial_match_helper(password, graph, graph_name)\n    @sorted matches\n\n  SHIFTED_RX: /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/\n  spatial_match_helper: (password, graph, graph_name) ->\n    matches = []\n    i = 0\n    while i < password.length - 1\n      j = i + 1\n      last_direction = null\n      turns = 0\n      if graph_name in ['qwerty', 'dvorak'] and @SHIFTED_RX.exec(password.charAt(i))\n        # initial character is shifted\n        shifted_count = 1\n      else\n        shifted_count = 0\n      loop\n        prev_char = password.charAt(j-1)\n        found = false\n        found_direction = -1\n        cur_direction = -1\n        adjacents = graph[prev_char] or []\n        # consider growing pattern by one character if j hasn't gone over the edge.\n        if j < password.length\n          cur_char = password.charAt(j)\n          for adj in adjacents\n            cur_direction += 1\n            if adj and adj.indexOf(cur_char) != -1\n              found = true\n              found_direction = cur_direction\n              if adj.indexOf(cur_char) == 1\n                # index 1 in the adjacency means the key is shifted,\n                # 0 means unshifted: A vs a, % vs 5, etc.\n                # for example, 'q' is adjacent to the entry '2@'.\n                # @ is shifted w/ index 1, 2 is unshifted.\n                shifted_count += 1\n              if last_direction != found_direction\n                # adding a turn is correct even in the initial case when last_direction is null:\n                # every spatial pattern starts with a turn.\n                turns += 1\n                last_direction = found_direction\n              break\n        # if the current pattern continued, extend j and try to grow again\n        if found\n          j += 1\n        # otherwise push the pattern discovered so far, if any...\n        else\n          if j - i > 2 # don't consider length 1 or 2 chains.\n            matches.push\n              pattern: 'spatial'\n              i: i\n              j: j-1\n              token: password[i...j]\n              graph: graph_name\n              turns: turns\n              shifted_count: shifted_count\n          # ...and then start a new search for the rest of the password.\n          i = j\n          break\n    matches\n\n  #-------------------------------------------------------------------------------\n  # repeats (aaa, abcabcabc) and sequences (abcdef) ------------------------------\n  #-------------------------------------------------------------------------------\n\n  repeat_match: (password) ->\n    matches = []\n    greedy = /(.+)\\1+/g\n    lazy = /(.+?)\\1+/g\n    lazy_anchored = /^(.+?)\\1+$/\n    lastIndex = 0\n    while lastIndex < password.length\n      greedy.lastIndex = lazy.lastIndex = lastIndex\n      greedy_match = greedy.exec password\n      lazy_match = lazy.exec password\n      break unless greedy_match?\n      if greedy_match[0].length > lazy_match[0].length\n        # greedy beats lazy for 'aabaab'\n        #   greedy: [aabaab, aab]\n        #   lazy:   [aa,     a]\n        match = greedy_match\n        # greedy's repeated string might itself be repeated, eg.\n        # aabaab in aabaabaabaab.\n        # run an anchored lazy match on greedy's repeated string\n        # to find the shortest repeated string\n        base_token = lazy_anchored.exec(match[0])[1]\n      else\n        # lazy beats greedy for 'aaaaa'\n        #   greedy: [aaaa,  aa]\n        #   lazy:   [aaaaa, a]\n        match = lazy_match\n        base_token = match[1]\n      [i, j] = [match.index, match.index + match[0].length - 1]\n      # recursively match and score the base string\n      base_analysis = scoring.most_guessable_match_sequence(\n        base_token\n        @omnimatch base_token\n      )\n      base_matches = base_analysis.sequence\n      base_guesses = base_analysis.guesses\n      matches.push\n        pattern: 'repeat'\n        i: i\n        j: j\n        token: match[0]\n        base_token: base_token\n        base_guesses: base_guesses\n        base_matches: base_matches\n        repeat_count: match[0].length / base_token.length\n      lastIndex = j + 1\n    matches\n\n  MAX_DELTA: 5\n  sequence_match: (password) ->\n    # Identifies sequences by looking for repeated differences in unicode codepoint.\n    # this allows skipping, such as 9753, and also matches some extended unicode sequences\n    # such as Greek and Cyrillic alphabets.\n    #\n    # for example, consider the input 'abcdb975zy'\n    #\n    # password: a   b   c   d   b    9   7   5   z   y\n    # index:    0   1   2   3   4    5   6   7   8   9\n    # delta:      1   1   1  -2  -41  -2  -2  69   1\n    #\n    # expected result:\n    # [(i, j, delta), ...] = [(0, 3, 1), (5, 7, -2), (8, 9, 1)]\n\n    return [] if password.length == 1\n\n    update = (i, j, delta) =>\n      if j - i > 1 or Math.abs(delta) == 1\n        if 0 < Math.abs(delta) <= @MAX_DELTA\n          token = password[i..j]\n          if /^[a-z]+$/.test(token)\n            sequence_name = 'lower'\n            sequence_space = 26\n          else if /^[A-Z]+$/.test(token)\n            sequence_name = 'upper'\n            sequence_space = 26\n          else if /^\\d+$/.test(token)\n            sequence_name = 'digits'\n            sequence_space = 10\n          else\n            # conservatively stick with roman alphabet size.\n            # (this could be improved)\n            sequence_name = 'unicode'\n            sequence_space = 26\n          result.push\n            pattern: 'sequence'\n            i: i\n            j: j\n            token: password[i..j]\n            sequence_name: sequence_name\n            sequence_space: sequence_space\n            ascending: delta > 0\n\n    result = []\n    i = 0\n    last_delta = null\n\n    for k in [1...password.length]\n      delta = password.charCodeAt(k) - password.charCodeAt(k - 1)\n      unless last_delta?\n        last_delta = delta\n      continue if delta == last_delta\n      j = k - 1\n      update(i, j, last_delta)\n      i = j\n      last_delta = delta\n    update(i, password.length - 1, last_delta)\n    result\n\n  #-------------------------------------------------------------------------------\n  # regex matching ---------------------------------------------------------------\n  #-------------------------------------------------------------------------------\n\n  regex_match: (password, _regexen = REGEXEN) ->\n    matches = []\n    for name, regex of _regexen\n      regex.lastIndex = 0 # keeps regex_match stateless\n      while rx_match = regex.exec password\n        token = rx_match[0]\n        matches.push\n          pattern: 'regex'\n          token: token\n          i: rx_match.index\n          j: rx_match.index + rx_match[0].length - 1\n          regex_name: name\n          regex_match: rx_match\n    @sorted matches\n\n  #-------------------------------------------------------------------------------\n  # date matching ----------------------------------------------------------------\n  #-------------------------------------------------------------------------------\n\n  date_match: (password) ->\n    # a \"date\" is recognized as:\n    #   any 3-tuple that starts or ends with a 2- or 4-digit year,\n    #   with 2 or 0 separator chars (1.1.91 or 1191),\n    #   maybe zero-padded (01-01-91 vs 1-1-91),\n    #   a month between 1 and 12,\n    #   a day between 1 and 31.\n    #\n    # note: this isn't true date parsing in that \"feb 31st\" is allowed,\n    # this doesn't check for leap years, etc.\n    #\n    # recipe:\n    # start with regex to find maybe-dates, then attempt to map the integers\n    # onto month-day-year to filter the maybe-dates into dates.\n    # finally, remove matches that are substrings of other matches to reduce noise.\n    #\n    # note: instead of using a lazy or greedy regex to find many dates over the full string,\n    # this uses a ^...$ regex against every substring of the password -- less performant but leads\n    # to every possible date match.\n    matches = []\n    maybe_date_no_separator = /^\\d{4,8}$/\n    maybe_date_with_separator = ///\n      ^\n      ( \\d{1,4} )    # day, month, year\n      ( [\\s/\\\\_.-] ) # separator\n      ( \\d{1,2} )    # day, month\n      \\2             # same separator\n      ( \\d{1,4} )    # day, month, year\n      $\n    ///\n\n    # dates without separators are between length 4 '1191' and 8 '11111991'\n    for i in [0..password.length - 4]\n      for j in [i + 3..i + 7]\n        break if j >= password.length\n        token = password[i..j]\n        continue unless maybe_date_no_separator.exec token\n        candidates = []\n        for [k,l] in DATE_SPLITS[token.length]\n          dmy = @map_ints_to_dmy [\n            parseInt token[0...k]\n            parseInt token[k...l]\n            parseInt token[l...]\n          ]\n          candidates.push dmy if dmy?\n        continue unless candidates.length > 0\n        # at this point: different possible dmy mappings for the same i,j substring.\n        # match the candidate date that likely takes the fewest guesses: a year closest to 2000.\n        # (scoring.REFERENCE_YEAR).\n        #\n        # ie, considering '111504', prefer 11-15-04 to 1-1-1504\n        # (interpreting '04' as 2004)\n        best_candidate = candidates[0]\n        metric = (candidate) -> Math.abs candidate.year - scoring.REFERENCE_YEAR\n        min_distance = metric candidates[0]\n        for candidate in candidates[1..]\n          distance = metric candidate\n          if distance < min_distance\n            [best_candidate, min_distance] = [candidate, distance]\n        matches.push\n          pattern: 'date'\n          token: token\n          i: i\n          j: j\n          separator: ''\n          year: best_candidate.year\n          month: best_candidate.month\n          day: best_candidate.day\n\n    # dates with separators are between length 6 '1/1/91' and 10 '11/11/1991'\n    for i in [0..password.length - 6]\n      for j in [i + 5..i + 9]\n        break if j >= password.length\n        token = password[i..j]\n        rx_match = maybe_date_with_separator.exec token\n        continue unless rx_match?\n        dmy = @map_ints_to_dmy [\n          parseInt rx_match[1]\n          parseInt rx_match[3]\n          parseInt rx_match[4]\n        ]\n        continue unless dmy?\n        matches.push\n          pattern: 'date'\n          token: token\n          i: i\n          j: j\n          separator: rx_match[2]\n          year: dmy.year\n          month: dmy.month\n          day: dmy.day\n\n    # matches now contains all valid date strings in a way that is tricky to capture\n    # with regexes only. while thorough, it will contain some unintuitive noise:\n    #\n    # '2015_06_04', in addition to matching 2015_06_04, will also contain\n    # 5(!) other date matches: 15_06_04, 5_06_04, ..., even 2015 (matched as 5/1/2020)\n    #\n    # to reduce noise, remove date matches that are strict substrings of others\n    @sorted matches.filter (match) ->\n      is_submatch = false\n      for other_match in matches\n        continue if match is other_match\n        if other_match.i <= match.i and other_match.j >= match.j\n          is_submatch = true\n          break\n      not is_submatch\n\n  map_ints_to_dmy: (ints) ->\n    # given a 3-tuple, discard if:\n    #   middle int is over 31 (for all dmy formats, years are never allowed in the middle)\n    #   middle int is zero\n    #   any int is over the max allowable year\n    #   any int is over two digits but under the min allowable year\n    #   2 ints are over 31, the max allowable day\n    #   2 ints are zero\n    #   all ints are over 12, the max allowable month\n    return if ints[1] > 31 or ints[1] <= 0\n    over_12 = 0\n    over_31 = 0\n    under_1 = 0\n    for int in ints\n      return if 99 < int < DATE_MIN_YEAR or int > DATE_MAX_YEAR\n      over_31 += 1 if int > 31\n      over_12 += 1 if int > 12\n      under_1 += 1 if int <= 0\n    return if over_31 >= 2 or over_12 == 3 or under_1 >= 2\n\n    # first look for a four digit year: yyyy + daymonth or daymonth + yyyy\n    possible_year_splits = [\n      [ints[2], ints[0..1]] # year last\n      [ints[0], ints[1..2]] # year first\n    ]\n    for [y, rest] in possible_year_splits\n      if DATE_MIN_YEAR <= y <= DATE_MAX_YEAR\n        dm = @map_ints_to_dm rest\n        if dm?\n          return {\n            year: y\n            month: dm.month\n            day: dm.day\n          }\n        else\n          # for a candidate that includes a four-digit year,\n          # when the remaining ints don't match to a day and month,\n          # it is not a date.\n          return\n\n    # given no four-digit year, two digit years are the most flexible int to match, so\n    # try to parse a day-month out of ints[0..1] or ints[1..0]\n    for [y, rest] in possible_year_splits\n      dm = @map_ints_to_dm rest\n      if dm?\n        y = @two_to_four_digit_year y\n        return {\n          year: y\n          month: dm.month\n          day: dm.day\n        }\n\n  map_ints_to_dm: (ints) ->\n    for [d, m] in [ints, ints.slice().reverse()]\n      if 1 <= d <= 31 and 1 <= m <= 12\n        return {\n          day: d\n          month: m\n        }\n\n  two_to_four_digit_year: (year) ->\n    if year > 99\n      year\n    else if year > 50\n      # 87 -> 1987\n      year + 1900\n    else\n      # 15 -> 2015\n      year + 2000\n\nmodule.exports = matching\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}